/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Description: Implementation of 1) get/set sdp encryption metadata;
 *                                2) update sdp metadata.
 * Author: LAI Xinyi
 * Create: 2020-02-12
 */
#include "sdp_metadata.h"

#include <linux/fs.h>
#include <linux/f2fs_fs.h>
#include <linux/random.h>
#include "xattr.h"
#include "sdp.h"
#include "fbe3_trace.h"

#include <linux/hisi/fbe_ctrl.h>

/*
 * In FBE3, regular files' nonce is generated by 2 segments: 48 bytes for
 * ci_key, 16 bytes for metadata; directory files' nonce is generated as usual.
 */
void generate_nonce(u8 *nonce, struct inode *inode, size_t len)
{
	if (S_ISREG(inode->i_mode) && inode->i_sb->s_cop->is_inline_encrypted &&
	    inode->i_sb->s_cop->is_inline_encrypted(inode)) {
		get_random_bytes(nonce, CI_KEY_LEN_NEW);
		get_random_bytes(nonce + CI_KEY_LEN_NEW, METADATA_BYTE_IN_KDF);
	} else {
		get_random_bytes(nonce, len);
	}
}

int f2fs_get_metadata_context(struct inode *inode, void *ctx, size_t len,
			      void *fs_data)
{
	return f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
			     F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
			     fs_data);
}

int f2fs_get_sdp_metadata_context(struct inode *inode, void *ctx, size_t len,
				  void *fs_data)
{
	int ret = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data);
	if (ret != len)
		pr_err("%s:f2fs_getxattr error %d ino = %llu\r\n", __func__,
		       ret, inode->i_ino);

	return ret;
}

int f2fs_set_sdp_metadata_context(struct inode *inode, const void *ctx,
				  size_t len, void *fs_data)
{
	int ret = f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data, XATTR_CREATE);
	if (ret == -EEXIST)
		ret = f2fs_update_sdp_metadata_context(inode, ctx, len,
						       fs_data);

	return ret;
}

int f2fs_update_sdp_metadata_context(struct inode *inode, const void *ctx,
				     size_t len, void *fs_data)
{
	int ret = f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data, XATTR_REPLACE);
	if (ret)
		pr_err("%s: XATTR_REPLACE fail %d ino = %llu\r\n", __func__,
		       ret, inode->i_ino);

	return ret;
}

static int ece_metadata_get(u8 *metadata)
{
	ktime_t start_time, end_time;
	uint64_t hisi_delay;
	int ret;

	if (!metadata) {
		pr_err("%s: invalid metadata\n", __func__);
		return -EINVAL;
	}

	start_time = ktime_get();
	ret = get_metadata(metadata, METADATA_BYTE_IN_KDF);
	end_time = ktime_get();
	if (ret) {
		if (end_time >= start_time) {
			hisi_delay = ktime_to_ms(end_time - start_time);
			gen_meta_upload_bigdata(ECE_GEN_METADATA, ret,
							hisi_delay);
		} else {
			pr_err("%s: runtime error\n", __func__);
		}
	}

	return ret;
}

static int sece_metadata_get(u8 *metadata, u8 *fpubkey, int keyindex, int flag)
{
	ktime_t start_time, end_time;
	uint64_t hisi_delay;
	int ret;
	struct fbex_sece_param param = {0};

	if (!metadata || !fpubkey) {
		pr_err("%s: invalid metadata\n", __func__);
		return -EINVAL;
	}
	param.cmd = flag;
	param.idx = keyindex;
	param.pubkey = fpubkey;
	param.key_len = FPUBKEY_LEN;
	param.metadata = metadata;
	param.iv_len = METADATA_BYTE_IN_KDF;

	start_time = ktime_get();
	ret = get_metadata_sece(&param);
	end_time = ktime_get();
	if (ret) {
		if (end_time >= start_time) {
			hisi_delay = ktime_to_ms(end_time - start_time);
			gen_meta_upload_bigdata(SECE_GEN_METADATA, ret,
							hisi_delay);
		} else {
			pr_err("%s: runtime error", __func__);
		}
	}

	return ret;
}

int fscrypt_open_metadata_config(struct inode *inode,
				 struct fscrypt_info *ci_info)
{
	int res;

	if (!ci_info || !ci_info->ci_key) {
		pr_err("[FBE3]%s: no ci_info for inline-encrypted file!\n",
		       __func__);
		return -ENODATA;
	}

	res = inode->i_sb->s_cop->get_metadata_context(
		inode, ci_info->ci_metadata, METADATA_BYTE_IN_KDF, NULL);
	/*
	* if getting metadata failed, this is a new file after hota
	* update. Therefore, we reuse the last 16 Bytes of ci_key as
	* metadata. if not, this is an old file, we keep the old method
	*/
	if (res == -ENODATA) {
		memcpy(ci_info->ci_metadata, ci_info->ci_key + CI_KEY_LEN_NEW,
		       METADATA_BYTE_IN_KDF);
		ci_info->ci_key_len = CI_KEY_LEN_NEW;
	} else if (res < 0) {
		pr_err("%s: inode %lu get metadata failed, res %d\n", __func__,
		       inode->i_ino, res);
		return res;
	} else if (res != METADATA_BYTE_IN_KDF) {
		pr_err("%s: inode %lu metadata invalid length: %d\n", __func__,
		       inode->i_ino, res);
		return -EINVAL;
	}

	ci_info->ci_key_index |= (CD << FILE_ENCRY_TYPE_BEGIN_BIT);

	return 0;
}

int fscrypt_open_sece_metadata_config(struct inode *inode,
				      struct fscrypt_info *ci_info,
				      void *fs_data)
{
	struct f2fs_sdp_fscrypt_context sdp_ctx;
	struct f2fs_sb_info *sb = F2FS_I_SB(inode);
	u8 fpubkey[FPUBKEY_LEN];
	int err = 0;
	int keyindex;
	int res;

	if (!sb || !sb->s_sdp_cop) {
		pr_err("[FBE3]%s: no super block or sdp ops for inode %lu\n",
		       __func__, inode->i_ino);
		return -ENODATA;
	}
	res = sb->s_sdp_cop->get_sdp_context(inode, &sdp_ctx, sizeof(sdp_ctx),
					     fs_data);
	if (res != sizeof(sdp_ctx)) {
		pr_err("%s: get sdp ctx failed, ino = %lu\n", __func__,
		       inode->i_ino);
		return -EINVAL;
	}

	if (sdp_ctx.sdpclass == FSCRYPT_SDP_SECE_CLASS) {
		err = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (err != FPUBKEY_LEN) {
			pr_err("%s: inode(%lu) get sece fpubkey failed, err %d\n",
			       __func__, inode->i_ino, err);
			return -EINVAL;
		}

		keyindex = ci_info->ci_key_index & FILE_ENCRY_TYPE_MASK;
		err = sece_metadata_get(ci_info->ci_metadata, fpubkey, keyindex,
					SEC_FILE_ENCRY_CMD_ID_GEN_METADATA);
		if (err) {
			pr_err("[FBE3]%s: screen locked, inode(%lu) get sece metadata failed, err:%d\n",
			       __func__, inode->i_ino, err);
			return -EKEYREVOKED;
		}
		ci_info->ci_key_index &= 0xff;
		ci_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	}
	return err;
}

int f2fs_get_sdp_ece_metadata(struct inode *inode, struct f2fs_sb_info *sb,
			      struct fscrypt_info *crypt_info, void *fs_data,
			      int flag)
{
	int res;

	if (F2FS_INODE_IS_ENABLED_SDP_ECE_ENCRYPTION(flag)) {
		res = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, crypt_info->ci_metadata, METADATA_BYTE_IN_KDF,
			NULL);
		if (unlikely(res != METADATA_BYTE_IN_KDF)) {
			pr_err("%s: inode(%lu) get ece metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return -EINVAL;
		}
		res = 0;
	} else {
		res = ece_metadata_get(crypt_info->ci_metadata);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: ece generating metadata failed, res:%d\n",
			       __func__, res);
			return -EKEYREJECTED;
		}

		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, crypt_info->ci_metadata, METADATA_BYTE_IN_KDF,
			fs_data);
		if (unlikely(res)) {
			pr_err("[FBE3]f2fs_sdp %s: inode %lu set metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return res;
		}
	}
	crypt_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
	crypt_info->ci_key_index |= (ECE << FILE_ENCRY_TYPE_BEGIN_BIT);

	return res;
}

int f2fs_get_sdp_sece_metadata(struct inode *inode, struct f2fs_sb_info *sb,
			       struct fscrypt_info *crypt_info, void *fs_data,
			       u32 flag)
{
	u8 fpubkey[FPUBKEY_LEN];
	int res;
	int keyindex;

	if (!F2FS_INODE_IS_ENABLED_SDP_SECE_ENCRYPTION(flag)) {
		res = sece_metadata_get(crypt_info->ci_metadata, fpubkey,
					crypt_info->ci_key_index,
					SEC_FILE_ENCRY_CMD_ID_NEW_SECE);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: sece generating metadata failed, res:%d\n",
			       __func__, res);
			return -EKEYREJECTED;
		}
		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: inode(%lu) set metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return res;
		}
	} else {
		res = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (res != FPUBKEY_LEN) {
			pr_err("%s: inode(%lu) get sece fpubkey failed, res %d\n",
			       __func__, inode->i_ino, res);
			return -EINVAL;
		}

		keyindex = crypt_info->ci_key_index & FILE_ENCRY_TYPE_MASK;
		res = sece_metadata_get(crypt_info->ci_metadata, fpubkey, keyindex,
					SEC_FILE_ENCRY_CMD_ID_GEN_METADATA);
		if (res) {
			pr_err("[FBE3]%s: screen locked, inode(%lu) get sece metadata failed, res:%d\n",
			       __func__, inode->i_ino, res);
			return -EKEYREVOKED;
		}
	}
	crypt_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
	crypt_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);

	return res;
}

int f2fs_update_metadata_sdp_crypto(struct inode *inode, void *fs_data,
				    struct f2fs_sdp_fscrypt_context *sdp_ctx)
{
	int res = 0;
	struct fscrypt_info *ci_info = inode->i_crypt_info;
	struct f2fs_sb_info *sb = F2FS_I_SB(inode);
	u8 fpubkey[FPUBKEY_LEN];
	struct dentry *dentry = NULL;

	if (sdp_ctx->sdpclass == FSCRYPT_SDP_ECE_CLASS) {
		res = ece_metadata_get(ci_info->ci_metadata);
		if (res) {
			pr_err("[FBE3]%s: ece generating metadata failed, res:%d\n",
			       __func__, res);
			res = -EKEYREJECTED;
			return res;
		}
		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, ci_info->ci_metadata, METADATA_BYTE_IN_KDF,
			fs_data);

		ci_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
		ci_info->ci_key_index |= (ECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	} else if (sdp_ctx->sdpclass == FSCRYPT_SDP_SECE_CLASS) {
		res = sece_metadata_get(ci_info->ci_metadata, fpubkey,
					ci_info->ci_key_index,
					SEC_FILE_ENCRY_CMD_ID_NEW_SECE);
		if (res) {
			pr_err("[FBE3]%s: sece generating metadata failed, res:%d\n",
			       __func__, res);
			res = -EKEYREJECTED;
			return res;
		}

		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		ci_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
		ci_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	}

	if (res) {
		pr_err("[FBE3]f2fs_sdp %s: inode %lu set metadata failed, res %d\n",
		       __func__, inode->i_ino, res);
		dentry = d_find_any_alias(inode);
		if (dentry)
			pr_err("[FBE3]%s: dir: %s\n", __func__,
			       dentry->d_name.name);
	}

	return res;
}

bool f2fs_encrypt_file_check(struct inode *inode)
{
	struct fscrypt_info *ci_info = NULL;
	struct f2fs_sb_info *sb = NULL;

	if (unlikely(!inode))
		return false;
	sb = F2FS_I_SB(inode);
	ci_info = inode->i_crypt_info;

	/* If ECE && Lock Screen return true, otherwise, return false */
	if (ci_info) {
		if ((ci_info->ci_hw_enc_flag ==
		     F2FS_XATTR_SDP_ECE_ENABLE_FLAG) &&
		    f2fs_inode_check_sdp_keyring(ci_info->ci_master_key, 0)) {
			pr_err("%s: ECE file check sdp keyring failed! \n",
			       __func__);
			return true;
		}
	}
	return false;
}

enum encrypto_type f2fs_get_encrypt_type(struct inode *inode)
{
	struct fscrypt_info *ci_info = inode->i_crypt_info;
	if (!ci_info)
		return PLAIN;
	if (ci_info->ci_hw_enc_flag == F2FS_XATTR_SDP_ECE_ENABLE_FLAG)
		return ECE;
	if (ci_info->ci_hw_enc_flag == F2FS_XATTR_SDP_SECE_ENABLE_FLAG)
		return SECE;
	return CD;
}

